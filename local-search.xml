<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Caffeine一级缓存介绍和应用</title>
    <link href="/2022/09/caffeine-intro-and-apply.html"/>
    <url>/2022/09/caffeine-intro-and-apply.html</url>
    
    <content type="html"><![CDATA[<h2 id="Caffeine介绍"><a href="#Caffeine介绍" class="headerlink" title="Caffeine介绍"></a>Caffeine介绍</h2><h3 id="redis和caffeine的区别"><a href="#redis和caffeine的区别" class="headerlink" title="redis和caffeine的区别"></a>redis和caffeine的区别</h3><p>相同点就不用说，广义上都是缓存的方式。咱们就说说不同。</p><ul><li>redis是将数据存储到内存里；caffeine是将数据存储在本地应用里</li><li>caffeine和redis相比，没有了网络IO上的消耗</li></ul><p>那么在高并发场景中，一般我们都是结合使用，形成一二级缓存。caffeine作为一级缓存，redis作为二级缓存。<br>使用流程大致如下：去一级缓存中查找数据（caffeine-本地应用内）如果没有的话，去二级缓存中查找数据（redis-内存）再没有，再去数据库中查找数据（数据库-磁盘）。</p><p>caffeine项目地址：<a href="https://github.com/ben-manes/caffeine">ben-manes&#x2F;caffeine: A high performance caching library for Java (github.com)</a></p><h2 id="caffeine的应用"><a href="#caffeine的应用" class="headerlink" title="caffeine的应用"></a>caffeine的应用</h2><p>Caffeine 相当于一个缓存工厂，可以创建出多个缓存实例 Cache。这些缓存实例都继承了 Caffeine 的参数配置，Caffeine 是如何配置的，这些缓存实例就具有什么样的特性和功能。<br>Caffeine 是目前性能最好的本地缓存，因此，在考虑使用本地缓存时，直接选择 Caffeine 即可。</p><h3 id="将caffeine作为一级缓存使用"><a href="#将caffeine作为一级缓存使用" class="headerlink" title="将caffeine作为一级缓存使用"></a>将caffeine作为一级缓存使用</h3><h4 id="1-配置相关"><a href="#1-配置相关" class="headerlink" title="1.配置相关"></a>1.配置相关</h4><ul><li>maven引包，可自行根据流行版本更改版本号：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>缓存配置类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;<br><span class="hljs-keyword">import</span> org.springframework.cache.caffeine.CaffeineCache;<br><span class="hljs-keyword">import</span> org.springframework.cache.interceptor.SimpleKeyGenerator;<br><span class="hljs-keyword">import</span> org.springframework.cache.support.AbstractCacheManager;<br><span class="hljs-keyword">import</span> org.springframework.cache.support.SimpleCacheManager;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Aunero</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 缓存配置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置缓存管理器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 缓存管理器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> AbstractCacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleCacheManager</span>();<br>        <span class="hljs-comment">//把各个cache注册到cacheManager中，CaffeineCache实现了org.springframework.cache.Cache接口</span><br>        List&lt;CaffeineCache&gt; caches = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Arrays.asList(CacheInstance.values()).forEach(cacheInstance -&gt; &#123;<br>            <span class="hljs-type">CaffeineCache</span> <span class="hljs-variable">caffeineCache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CaffeineCache</span>(cacheInstance.name(), Caffeine.newBuilder()<br>                    .recordStats()<br>                    .expireAfterWrite(cacheInstance.getTtl(), TimeUnit.SECONDS)<br>                    .build());<br>            caches.add(caffeineCache);<br>        &#125;);<br>        cacheManager.setCaches(caches);<br>        <span class="hljs-keyword">return</span> cacheManager;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SimpleKeyGenerator <span class="hljs-title function_">simpleKeyGenerator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleKeyGenerator</span>();<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>缓存代理类，用来获取缓存和刷新：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.hutool.core.util.ReflectUtil;<br><span class="hljs-keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.cache.Cache;<br><span class="hljs-keyword">import</span> org.springframework.cache.caffeine.CaffeineCache;<br><span class="hljs-keyword">import</span> org.springframework.cache.support.AbstractCacheManager;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Aunero</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 缓存代理类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheCreator</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AbstractCacheManager cacheManager;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取缓存，如果获取不到创建一个</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cacheInstance</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Cache <span class="hljs-title function_">getCache</span><span class="hljs-params">(CacheInstance cacheInstance, List&lt;String&gt; values)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">cacheNameSuffix</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">&quot;&amp;&quot;</span>, values);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">cacheName</span> <span class="hljs-operator">=</span> cacheInstance.name() + <span class="hljs-string">&quot;&amp;&quot;</span> + cacheNameSuffix;<br>        <span class="hljs-type">Cache</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> cacheManager.getCache(cacheName);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == cache) &#123;<br>            <span class="hljs-keyword">synchronized</span> (cacheName.intern()) &#123;<br>                cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CaffeineCache</span>(cacheName, Caffeine.newBuilder()<br>                        .recordStats()<br>                        .expireAfterWrite(cacheInstance.getTtl(), TimeUnit.SECONDS)<br>                        .build());<br>                Map&lt;String, Cache&gt; caches = (ConcurrentHashMap&lt;String, Cache&gt;) ReflectUtil.getFieldValue(cacheManager, <span class="hljs-string">&quot;cacheMap&quot;</span>);<br>                caches.put(cacheName, cache);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cache;<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>我们还需要一个对业务数据进行区分的缓存枚举类，这些缓存配置将在缓存管理器初始化时加载：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.hutool.core.util.RandomUtil;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Aunero</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 缓存实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CacheInstance</span> &#123;<br>    <span class="hljs-comment">//枚举自行定义</span><br>    STUDENT_INFO,<span class="hljs-comment">//学生信息</span><br>    CLASS_INFO(<span class="hljs-number">600</span>, <span class="hljs-number">1024</span>),<span class="hljs-comment">//班级信息, 可自定义过期时间和最大数量</span><br>    ;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ttl</span> <span class="hljs-operator">=</span> RandomUtil.randomInt(<span class="hljs-number">300</span>, <span class="hljs-number">360</span>);        <span class="hljs-comment">//默认过期时间  5分钟~6分钟</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>;    <span class="hljs-comment">//最大數量</span><br><br>    CacheInstance() &#123;<br>    &#125;<br><br><br>    CacheInstance(<span class="hljs-type">int</span> ttl) &#123;<br>        <span class="hljs-built_in">this</span>.ttl = ttl;<br>    &#125;<br><br>    CacheInstance(<span class="hljs-type">int</span> ttl, <span class="hljs-type">int</span> maxSize) &#123;<br>        <span class="hljs-built_in">this</span>.ttl = ttl;<br>        <span class="hljs-built_in">this</span>.maxSize = maxSize;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaxSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> maxSize;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaxSize</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.maxSize = maxSize;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTtl</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ttl;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTtl</span><span class="hljs-params">(<span class="hljs-type">int</span> ttl)</span> &#123;<br>        <span class="hljs-built_in">this</span>.ttl = ttl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-注解实现和工具类"><a href="#2-注解实现和工具类" class="headerlink" title="2.注解实现和工具类"></a>2.注解实现和工具类</h4><p>配置完了缓存，我们需要在业务上使用,我们可以通过切面注解的方式来实现缓存,这样可以大大减少业务代码和缓存代码的耦合性。</p><ul><li>缓存注解类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Aunero</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Cacheable &#123;<br><br>    CacheInstance <span class="hljs-title function_">cacheName</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * cache缓存名拼接后缀的参数</span><br><span class="hljs-comment">     * 可填方法名或者针对这个方法独一无二的标识</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    String[] cacheNameSuffix() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 缓存的键, 可以填入需要作为缓存依据的参数名,</span><br><span class="hljs-comment">     * 不写默认所有参数作为依据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    String [] keys() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>缓存删除注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Aunero</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CacheEvict &#123;<br><br>    CacheInstance[] cacheName() ;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * cache缓存名拼接后缀的参数，注意区分顺序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    String[] cacheNameSuffix() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>缓存切面实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.reflect.CodeSignature;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.cache.Cache;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Aunero</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 缓存切面处理类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheAspectHandler</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CacheCreator cacheCreator;<br><br>    <span class="hljs-comment">//缓存开启状态 也可以配置到配置文件中读取yml</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Boolean</span> <span class="hljs-variable">enableCache</span> <span class="hljs-operator">=</span> Boolean.TRUE;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取缓存, 没有则添加缓存在返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pjp</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cacheable</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;@annotation(cacheable)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">cacheResponse</span><span class="hljs-params">(ProceedingJoinPoint pjp, Cacheable cacheable)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        Object result;<br><br>        <span class="hljs-keyword">if</span> (enableCache) &#123;<br>            <span class="hljs-comment">//获取参数</span><br>            String[] argNames = ((CodeSignature) pjp.getSignature()).getParameterNames();<br>            Object[] args = pjp.getArgs();<br>            <span class="hljs-comment">//生成参数键值对</span><br>            Map&lt;String, Object&gt; argMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; argNames.length; i++) &#123;<br>                argMap.put(argNames[i], args[i]);<br>            &#125;<br><br>            String key;<br>            <span class="hljs-keyword">if</span>(cacheable.keys().length != <span class="hljs-number">0</span>)&#123;<br>                key = CacheUtil.generateCacheKeyByMapAndSpecifiedKeys(argMap, cacheable.keys());<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                key = CacheUtil.generateCacheKeyByMap(argMap);<br>            &#125;<br><br>            <span class="hljs-type">Cache</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> cacheCreator.getCache(cacheable.cacheName(), Arrays.asList(cacheable.cacheNameSuffix()));<br>            result = cache.get(key, Object.class);<br>            <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>                log.debug(String.format(<span class="hljs-string">&quot;命中缓存,实例：%s, 键：%s &quot;</span>, cache.getName(), key));<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result = pjp.proceed();<br>                cache.put(key, result);<br>                log.debug(String.format(<span class="hljs-string">&quot;缓存成功,实例：%s, 键：%s &quot;</span>, cache.getName(), key));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//不开启缓存 直接过方法</span><br>            result = pjp.proceed();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除缓存</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pjp</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cacheEvict</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;@annotation(cacheEvict)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">evictCacheResponse</span><span class="hljs-params">(ProceedingJoinPoint pjp, CacheEvict cacheEvict)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>        CacheInstance[] cacheInstances = cacheEvict.cacheName();<br>        Arrays.stream(cacheInstances).forEach(cacheInstance -&gt; &#123;<br>            <span class="hljs-type">Cache</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> cacheCreator.getCache(cacheInstance, Arrays.asList(cacheEvict.cacheNameSuffix()));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != cache) &#123;<br>                cache.clear();<br>                log.debug(String.format(<span class="hljs-string">&quot;清除缓存成功,实例：%s &quot;</span>, cache.getName()));<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> pjp.proceed();<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>使用到的缓存工具类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.hutool.core.util.ArrayUtil;<br><span class="hljs-keyword">import</span> cn.hutool.json.JSONUtil;<br><span class="hljs-keyword">import</span> org.springframework.cache.Cache;<br><span class="hljs-keyword">import</span> org.springframework.cache.interceptor.SimpleKey;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Aunero</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheUtil</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getValue</span><span class="hljs-params">(Cache cache, Object key, Class&lt;T&gt; returnClass)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cache == <span class="hljs-literal">null</span> || key == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cache.get(key, returnClass);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">generateCacheKey</span><span class="hljs-params">(Object... keys)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleKey</span>(keys);<br>        List&lt;Object&gt; objects = Arrays.asList(keys);<br>        <span class="hljs-keyword">return</span> objects.stream().map(o -&gt; o == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;null&quot;</span> : String.valueOf(o)).collect(Collectors.joining(<span class="hljs-string">&quot;&amp;&quot;</span>));<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cacheValue</span><span class="hljs-params">(Cache cache, Object value, Object... keys)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == cache) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;内部错误：缓存器为空&quot;</span>);<br>        &#125;<br>        cache.put(generateCacheKey(keys), value);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">generateCacheKeyByMap</span><span class="hljs-params">(Map&lt;String, Object&gt; argMap)</span> &#123;<br>        <span class="hljs-comment">//直接将参数转为json作为缓存key</span><br>        <span class="hljs-keyword">return</span> JSONUtil.toJsonStr(argMap);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">generateCacheKeyByMapAndSpecifiedKeys</span><span class="hljs-params">(Map&lt;String, Object&gt; argMap, String... keys)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ArrayUtil.isEmpty(keys)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;请指定缓存的key&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//将需要参数作为缓存key</span><br>        Map&lt;String, Object&gt; keysMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Arrays.stream(keys).forEach(key -&gt; keysMap.put(key, argMap.get(key)));<br>        <span class="hljs-keyword">return</span> generateCacheKeyByMap(keysMap);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-缓存使用"><a href="#3-缓存使用" class="headerlink" title="3.缓存使用"></a>3.缓存使用</h4><ul><li>添加缓存-情况1：将所有参数作为缓存key，无需配置keys</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(cacheName = CacheInstance.STUDENT_INFO,  //枚举类存放的缓存名</span><br><span class="hljs-meta">           cacheNameSuffix = &quot;selectStudentList&quot;)</span><span class="hljs-comment">//缓存前缀, 对这部分缓存的唯一标识, 这里可以使用方法名, 方便查找和删除</span><br><span class="hljs-keyword">public</span> Map <span class="hljs-title function_">selectStudentList</span><span class="hljs-params">(Student conditon, Clazz cls)</span>&#123;<br>    <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>添加缓存-情况2：部分参数作为缓存key，配置keys</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(cacheName = CacheInstance.STUDENT_INFO,  //枚举类存放的缓存名</span><br><span class="hljs-meta">           cacheNameSuffix = &quot;selectStudentList&quot;,//缓存前缀, 对这部分缓存的唯一标识, 这里可以使用方法名, 方便查找和删除</span><br><span class="hljs-meta">           keys= &#123;&quot;conditon&quot;&#125;)</span><span class="hljs-comment">//只需要将参数condition作为缓存key</span><br><span class="hljs-keyword">public</span> Map <span class="hljs-title function_">selectStudentList</span><span class="hljs-params">(Student conditon, Clazz cls)</span>&#123;<br>    <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缓存成功后，会打印缓存成功的日志，重复调用接口会打印命中缓存的日志，这时可以看到实例以及key</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">38.016</span> <span class="hljs-selector-attr">[http-nio-8097-exec-1]</span> DEBUG c<span class="hljs-selector-class">.k</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.CacheAspectHandler</span> - <span class="hljs-selector-attr">[cacheResponse,68]</span> - 缓存成功,实例：STUDENT_INFO&amp;selectStudentList, 键：&#123;<span class="hljs-string">&quot;conditon&quot;</span>:&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;张&quot;</span>&#125;&#125; <br><span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">44.243</span> <span class="hljs-selector-attr">[http-nio-8097-exec-2]</span> DEBUG c<span class="hljs-selector-class">.k</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.CacheAspectHandler</span> - <span class="hljs-selector-attr">[cacheResponse,63]</span> - 命中缓存,实例：STUDENT_INFO&amp;selectStudentList, 键：&#123;<span class="hljs-string">&quot;conditon&quot;</span>:&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;张&quot;</span>&#125;&#125; <br></code></pre></td></tr></table></figure><ul><li>删除缓存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheEvict(cacheName = CacheInstance.STUDENT_INFO,  //枚举类存放的缓存名</span><br><span class="hljs-meta">           cacheNameSuffix = &quot;selectStudentList&quot;)</span><span class="hljs-comment">//缓存前缀, 清除该标识下的所有缓存</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delCache</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>清除缓存成功，则会打印清除成功日志</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">14</span>:<span class="hljs-number">54</span>:<span class="hljs-number">43.911</span> <span class="hljs-selector-attr">[http-nio-8097-exec-5]</span> DEBUG c<span class="hljs-selector-class">.k</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.CacheAspectHandler</span> - <span class="hljs-selector-attr">[lambda$evictCacheResponse$0,94]</span> - 清除缓存成功,实例：STUDENT_INFO&amp;selectStudentList<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上只展示了Caffeine缓存的基础应用，基本的缓存需求可以满足，当然也可以在切面中加入redis作为二级缓存使用。</p><p>Caffeine缓存具有很好的性能和很强的扩展性，更多扩展用法可以参考Caffeine缓存的官方文档（<a href="https://github.com/ben-manes/caffeine/wiki/Population-zh-CN">Population zh CN · ben-manes&#x2F;caffeine Wiki (github.com)</a>），若代码有错误或不足的地方可以评论回复。</p><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><p><a href="https://blog.csdn.net/weixin_44427181/article/details/124817522">caffeine本地缓存的使用和详解_小曲同学呀的博客-CSDN博客_caffeine本地缓存</a></p>]]></content>
    
    
    <categories>
      
      <category>Java开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Caffeine</tag>
      
      <tag>缓存</tag>
      
      <tag>面向切面编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux防火墙常用命令</title>
    <link href="/2022/08/Linux-firewall-cmd.html"/>
    <url>/2022/08/Linux-firewall-cmd.html</url>
    
    <content type="html"><![CDATA[<h5 id="防火墙常用命令："><a href="#防火墙常用命令：" class="headerlink" title="防火墙常用命令："></a>防火墙常用命令：</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">firewall-cmd --state              <span class="hljs-comment">##查看防火墙状态，是否是running</span><br>firewall-cmd --reload              <span class="hljs-comment">##重新载入配置，比如添加规则之后，需要执行此命令</span><br>firewall-cmd --get-zones            <span class="hljs-comment">##列出支持的zone</span><br>firewall-cmd --get-services           <span class="hljs-comment">##列出支持的服务，在列表中的服务是放行的</span><br>firewall-cmd --query-service ftp        <span class="hljs-comment">##查看ftp服务是否支持，返回yes或者no</span><br>firewall-cmd --add-service=ftp         <span class="hljs-comment">##临时开放ftp服务</span><br>firewall-cmd --add-service=ftp --permanent   <span class="hljs-comment">##永久开放ftp服务</span><br>firewall-cmd --remove-service=ftp --permanent  <span class="hljs-comment">##永久移除ftp服务</span><br>firewall-cmd --add-port=80/tcp --permanent   <span class="hljs-comment">##永久添加80端口 </span><br>firewall-cmd --remove-port=80/tcp --permanent   <span class="hljs-comment">##永久移除80端口 </span><br>firewall-cmd --zone=public --list-ports    <span class="hljs-comment">##查看已开放的端口</span><br><br>iptables -L -n                 <span class="hljs-comment">##查看规则，这个命令是和iptables的相同的</span><br></code></pre></td></tr></table></figure><h5 id="1、开放端口"><a href="#1、开放端口" class="headerlink" title="1、开放端口"></a>1、开放端口</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">firewall-cmd --zone=public --add-port=5672/tcp --permanent  <span class="hljs-comment"># 开放5672端口</span><br><br>firewall-cmd --zone=public --remove-port=5672/tcp --permanent <span class="hljs-comment">#关闭5672端口</span><br><br>firewall-cmd --reload  <span class="hljs-comment"># 配置立即生效</span><br></code></pre></td></tr></table></figure><h5 id="2、查看防火墙所有开放的端口"><a href="#2、查看防火墙所有开放的端口" class="headerlink" title="2、查看防火墙所有开放的端口"></a>2、查看防火墙所有开放的端口</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">firewall-cmd --zone=public --list-ports<br></code></pre></td></tr></table></figure><h5 id="3-、关闭防火墙"><a href="#3-、关闭防火墙" class="headerlink" title="3.、关闭防火墙"></a>3.、关闭防火墙</h5><ul><li>如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl stop firewalld.service<br></code></pre></td></tr></table></figure><h5 id="4、查看防火墙状态"><a href="#4、查看防火墙状态" class="headerlink" title="4、查看防火墙状态"></a>4、查看防火墙状态</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">firewall-cmd --state<br></code></pre></td></tr></table></figure><h5 id="5、查看监听的端口"><a href="#5、查看监听的端口" class="headerlink" title="5、查看监听的端口"></a>5、查看监听的端口</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">netstat -lnpt<br></code></pre></td></tr></table></figure><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202208301156571.png"></p><ul><li><em>PS:centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools</em></li></ul><h5 id="6、检查端口被哪个进程占用"><a href="#6、检查端口被哪个进程占用" class="headerlink" title="6、检查端口被哪个进程占用"></a>6、检查端口被哪个进程占用</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">netstat -lnpt |grep 5672<br></code></pre></td></tr></table></figure><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202208301156139.png"></p><h5 id="7、查看进程的详细信息"><a href="#7、查看进程的详细信息" class="headerlink" title="7、查看进程的详细信息"></a>7、查看进程的详细信息</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps 6832<br></code></pre></td></tr></table></figure><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202208301156183.png"></p><h5 id="8、中止进程"><a href="#8、中止进程" class="headerlink" title="8、中止进程"></a>8、中止进程</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">kill</span> -9 6832<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过yum安装docker教程</title>
    <link href="/2022/08/yum-install-docker.html"/>
    <url>/2022/08/yum-install-docker.html</url>
    
    <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>Docker从1.13版本之后采用时间线的方式作为版本号，分为社区版CE和企业版EE。社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。社区版按照stable和edge两种方式发布，每个季度更新stable版本，如17.06，17.09；每个月份更新edge版本，如17.09，17.10。</p><h4 id="1-docker要求系统内核版本高于3-10，检查内核版本"><a href="#1-docker要求系统内核版本高于3-10，检查内核版本" class="headerlink" title="1.docker要求系统内核版本高于3.10，检查内核版本"></a>1.docker要求系统内核版本高于3.10，检查内核版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><h4 id="2-卸载旧版本（若安装过）"><a href="#2-卸载旧版本（若安装过）" class="headerlink" title="2.卸载旧版本（若安装过）"></a>2.卸载旧版本（若安装过）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove docker docker-common docker-selinux docker-engine<br></code></pre></td></tr></table></figure><h4 id="3-安装yum-utils，方便添加docker的yum源"><a href="#3-安装yum-utils，方便添加docker的yum源" class="headerlink" title="3.安装yum-utils，方便添加docker的yum源"></a>3.安装yum-utils，方便添加docker的yum源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure><h4 id="4-设置yum源"><a href="#4-设置yum源" class="headerlink" title="4.设置yum源"></a>4.设置yum源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><h4 id="5-查看仓库中的所有版本，选择特定的版本安装，默认安装最新版本"><a href="#5-查看仓库中的所有版本，选择特定的版本安装，默认安装最新版本" class="headerlink" title="5.查看仓库中的所有版本，选择特定的版本安装，默认安装最新版本"></a>5.查看仓库中的所有版本，选择特定的版本安装，默认安装最新版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r<br></code></pre></td></tr></table></figure><h4 id="6-安装docker"><a href="#6-安装docker" class="headerlink" title="6.安装docker"></a>6.安装docker</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y docker-ce<br><span class="hljs-comment">#若指定版本可在docker-ce后添加-版本号, 如docker-ce-17.12.0.ce</span><br></code></pre></td></tr></table></figure><h4 id="7-启动docker并加入开机启动"><a href="#7-启动docker并加入开机启动" class="headerlink" title="7.启动docker并加入开机启动"></a>7.启动docker并加入开机启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start docker <br>systemctl <span class="hljs-built_in">enable</span> docker <br></code></pre></td></tr></table></figure><h4 id="8-验证安装"><a href="#8-验证安装" class="headerlink" title="8.验证安装"></a>8.验证安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker version<span class="hljs-comment">#查看版本</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch中Data too large问题排查解决方案</title>
    <link href="/2022/07/es-data-too-large.html"/>
    <url>/2022/07/es-data-too-large.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在演示环境测试的时候，发现通过es查的数据偶尔会出现报错的情况，要根据实际情况进行排查和调优。</p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h4 id="1-问题定位"><a href="#1-问题定位" class="headerlink" title="1.问题定位"></a>1.问题定位</h4><p>查看es报错日志，看了一下大致意思是请求数据的时候内存超限了，触发了熔断器。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[2021-03-16T21:05:10,338]</span><span class="hljs-selector-attr">[DEBUG]</span><span class="hljs-selector-attr">[o.e.a.a.c.n.i.TransportNodesInfoAction]</span> <span class="hljs-selector-attr">[java-d-service-es-200-56-client-1]</span> failed to execute on node <span class="hljs-selector-attr">[hsF4JzeAQ6mflJRGnJIKzQ]</span><br>org<span class="hljs-selector-class">.elasticsearch</span><span class="hljs-selector-class">.transport</span><span class="hljs-selector-class">.RemoteTransportException</span>: <span class="hljs-selector-attr">[data-es-group-online-200-67-2]</span><span class="hljs-selector-attr">[10.110.200.67:9301]</span><span class="hljs-selector-attr">[cluster:monitor/nodes/info[n]</span>]<br>Caused by: org<span class="hljs-selector-class">.elasticsearch</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.breaker</span><span class="hljs-selector-class">.CircuitBreakingException</span>: <span class="hljs-selector-attr">[parent]</span> Data too large, data <span class="hljs-keyword">for</span> <span class="hljs-selector-attr">[&lt;transport_request&gt;]</span> would be <span class="hljs-selector-attr">[33093117638/30.8gb]</span>, which is larger than the limit of <span class="hljs-selector-attr">[31621696716/29.4gb]</span>, real usage: <span class="hljs-selector-attr">[33093114144/30.8gb]</span>, new bytes reserved: <span class="hljs-selector-attr">[3494/3.4kb]</span>, usages <span class="hljs-selector-attr">[request=0/0b, fielddata=0/0b, in_flight_requests=3494/3.4kb, accounting=104564949/99.7mb]</span><br> at org<span class="hljs-selector-class">.elasticsearch</span><span class="hljs-selector-class">.indices</span><span class="hljs-selector-class">.breaker</span><span class="hljs-selector-class">.HierarchyCircuitBreakerService</span><span class="hljs-selector-class">.checkParentLimit</span>(HierarchyCircuitBreakerService<span class="hljs-selector-class">.java</span>:<span class="hljs-number">342</span>) ~<span class="hljs-selector-attr">[elasticsearch-7.3.2.jar:7.3.2]</span><br> at ......<br></code></pre></td></tr></table></figure><p>拉下es源码，定位报错位置org.elasticsearch.indices.breaker.HierarchyCircuitBreakerService，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkParentLimit</span><span class="hljs-params">(<span class="hljs-type">long</span> newBytesReserved, String label)</span> <span class="hljs-keyword">throws</span> CircuitBreakingException &#123;<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">MemoryUsage</span> <span class="hljs-variable">memoryUsed</span> <span class="hljs-operator">=</span> memoryUsed(newBytesReserved);<br>     <span class="hljs-type">long</span> <span class="hljs-variable">parentLimit</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.parentSettings.getLimit();<br>     <span class="hljs-keyword">if</span> (memoryUsed.totalUsage &gt; parentLimit) &#123;<br>         <span class="hljs-built_in">this</span>.parentTripCount.incrementAndGet();<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;[parent] Data too large, data for [&quot;</span> + label + <span class="hljs-string">&quot;]&quot;</span> +<br>                 <span class="hljs-string">&quot; would be [&quot;</span> + memoryUsed.totalUsage + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteSizeValue</span>(memoryUsed.totalUsage) + <span class="hljs-string">&quot;]&quot;</span> +<br>                 <span class="hljs-string">&quot;, which is larger than the limit of [&quot;</span> +<br>                 parentLimit + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteSizeValue</span>(parentLimit) + <span class="hljs-string">&quot;]&quot;</span>);<br>         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.trackRealMemoryUsage) &#123;<br>             <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">realUsage</span> <span class="hljs-operator">=</span> memoryUsed.baseUsage;<br>             message.append(<span class="hljs-string">&quot;, real usage: [&quot;</span>);<br>             message.append(realUsage);<br>             message.append(<span class="hljs-string">&quot;/&quot;</span>);<br>             message.append(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteSizeValue</span>(realUsage));<br>             message.append(<span class="hljs-string">&quot;], new bytes reserved: [&quot;</span>);<br>             message.append(newBytesReserved);<br>             message.append(<span class="hljs-string">&quot;/&quot;</span>);<br>             message.append(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteSizeValue</span>(newBytesReserved));<br>             message.append(<span class="hljs-string">&quot;]&quot;</span>);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             message.append(<span class="hljs-string">&quot;, usages [&quot;</span>);<br>             message.append(String.join(<span class="hljs-string">&quot;, &quot;</span>,<br>                 <span class="hljs-built_in">this</span>.breakers.entrySet().stream().map(e -&gt; &#123;<br>                     <span class="hljs-keyword">final</span> <span class="hljs-type">CircuitBreaker</span> <span class="hljs-variable">breaker</span> <span class="hljs-operator">=</span> e.getValue();<br>                     <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">breakerUsed</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)(breaker.getUsed() * breaker.getOverhead());<br>                     <span class="hljs-keyword">return</span> e.getKey() + <span class="hljs-string">&quot;=&quot;</span> + breakerUsed + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteSizeValue</span>(breakerUsed);<br>                 &#125;)<br>                     .collect(Collectors.toList())));<br>             message.append(<span class="hljs-string">&quot;]&quot;</span>);<br>         &#125;<br>         <span class="hljs-comment">// derive durability of a tripped parent breaker depending on whether the majority of memory tracked by</span><br>         <span class="hljs-comment">// child circuit breakers is categorized as transient or permanent.</span><br>         CircuitBreaker.<span class="hljs-type">Durability</span> <span class="hljs-variable">durability</span> <span class="hljs-operator">=</span> memoryUsed.transientChildUsage &gt;= memoryUsed.permanentChildUsage ?<br>             CircuitBreaker.Durability.TRANSIENT : CircuitBreaker.Durability.PERMANENT;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircuitBreakingException</span>(message.toString(), memoryUsed.totalUsage, parentLimit, durability);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>从代码可以看出，当memoryUsed.totalUsage &gt; parentLimit时，才会出现熔断；parentLimit的值与配置indices.breaker.total.limit（默认值为95%或者70%）有关，它的默认值与indices.breaker.total.use_real_memory（默认值为true）的配置有关，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Setting&lt;Boolean&gt; USE_REAL_MEMORY_USAGE_SETTING =<br>    Setting.boolSetting(<span class="hljs-string">&quot;indices.breaker.total.use_real_memory&quot;</span>, <span class="hljs-literal">true</span>, Property.NodeScope);<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Setting&lt;ByteSizeValue&gt; TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING =<br>    Setting.memorySizeSetting(<span class="hljs-string">&quot;indices.breaker.total.limit&quot;</span>, settings -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (USE_REAL_MEMORY_USAGE_SETTING.get(settings)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;95%&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;70%&quot;</span>;<br>        &#125;<br>    &#125;, Property.Dynamic, Property.NodeScope);<br></code></pre></td></tr></table></figure><p>我们再来看看memoryUsed.totalUsage的值，它是该类的一个方法计算出来，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> MemoryUsage <span class="hljs-title function_">memoryUsed</span><span class="hljs-params">(<span class="hljs-type">long</span> newBytesReserved)</span> &#123;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">transientUsage</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">long</span> <span class="hljs-variable">permanentUsage</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <br>       <span class="hljs-keyword">for</span> (CircuitBreaker breaker : <span class="hljs-built_in">this</span>.breakers.values()) &#123;<br>           <span class="hljs-type">long</span> <span class="hljs-variable">breakerUsed</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)(breaker.getUsed() * breaker.getOverhead());<br>           <span class="hljs-keyword">if</span> (breaker.getDurability() == CircuitBreaker.Durability.TRANSIENT) &#123;<br>               transientUsage += breakerUsed;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (breaker.getDurability() == CircuitBreaker.Durability.PERMANENT) &#123;<br>               permanentUsage += breakerUsed;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.trackRealMemoryUsage) &#123;<br>           <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> currentMemoryUsage();<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemoryUsage</span>(current, current + newBytesReserved, transientUsage, permanentUsage);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-type">long</span> <span class="hljs-variable">parentEstimated</span> <span class="hljs-operator">=</span> transientUsage + permanentUsage;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemoryUsage</span>(parentEstimated, parentEstimated, transientUsage, permanentUsage);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>trackRealMemoryUsage的值（取自该配置indices.breaker.total.use_real_memory）决定了是使用实际的内存使用量还是child circuit breakers的内存使用量来判断熔断; 官方解释如下：</p><blockquote><p>Static setting determining whether the parent breaker should take real memory usage into account (<code>true</code>) or only consider the amount that is reserved by child circuit breakers (<code>false</code>). Defaults to <code>true</code></p></blockquote><h4 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h4><p>可以通过修改es节点配置来解决，给es配置文件elasticsearch.yml添加如下配置后重启节点即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">indices.breaker.total.use_real_memory:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>如果还无法解决，可以尝试增加es的jvm内存，修改jvm.options：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 根据实际情况修改内存, 此处分配了40g</span><br><span class="hljs-string">-Xms40g</span><br><span class="hljs-string">-Xmx40g</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ElasticSearch</tag>
      
      <tag>Linux</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多sheet模板导出表格</title>
    <link href="/2022/07/java-mult-sheet-export.html"/>
    <url>/2022/07/java-mult-sheet-export.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>需求是这样的，需要在页面导出列表表格时同时导出每项的详情数据，而且详情表格并不是一个常规的二维表格，就像图中这样的效果，所以要解决的最主要两个问题就是：多sheet实现、异形表格模板填充。</p><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202209200937705.png" alt="汇总"></p><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202209200938450.png" alt="详情"></p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="1-引入EasyExcel，为了减少代码量，不重复造轮子"><a href="#1-引入EasyExcel，为了减少代码量，不重复造轮子" class="headerlink" title="1.引入EasyExcel，为了减少代码量，不重复造轮子"></a>1.引入EasyExcel，为了减少代码量，不重复造轮子</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easyexcel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-写填充模板"><a href="#2-写填充模板" class="headerlink" title="2.写填充模板"></a>2.写填充模板</h3><ul><li>我导出的表格需要有个汇总表，填充的是集合需要在变量前加点，像这样 {.变量名}</li></ul><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202209200944486.png"></p><ul><li>这是详情表，模板可以根据你想要的来，填充非对象集合就不需要加点，这里要记住你需要生成多sheet的模板索引，这里位置在第二个，索引就是1，后面编码过程会用到</li></ul><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202209200944899.png"></p><h3 id="3-编码"><a href="#3-编码" class="headerlink" title="3.编码"></a>3.编码</h3><p><strong>3.1 生成多sheet名-数据对象键值对</strong></p><ul><li>根据你的业务需求，我们可以提前把模板生成好，再去填充数据，excel中不能出现重复的sheet名，我们要把重命名的sheet名和数据对应上，我们可以创建一个HashMap去存放sheet名和数据对，这是我的代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是我想要的数据集合</span><br>List&lt;Student&gt; list = taskList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(idList));<br><br><span class="hljs-comment">//sheet名-数据对象</span><br>Map&lt;String, Student&gt; sheetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (Student student : list) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sheetName</span> <span class="hljs-operator">=</span> student.getName() + <span class="hljs-string">&quot;--表格&quot;</span>;<br>    <span class="hljs-comment">//防止重名</span><br>    putIfContainsKey(sheetMap, sheetName, student);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我这里的sheet名是有可能会重复的，所以这里的put自己写了递归去重命名，putIfContainsKey方法如下，遇到重复的sheet直接递归在sheet名后加（1）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putIfContainsKey</span><span class="hljs-params">(Map sheetMap, String sheetName, Object data)</span> &#123;<br>    <span class="hljs-keyword">if</span>(sheetMap.containsKey(sheetName))&#123;<br>        putIfContainsKey(sheetMap, sheetName + <span class="hljs-string">&quot;(1)&quot;</span>, data);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        sheetMap.put(sheetName, data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.2 生成多sheet模板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取模板输入流</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\template.xlsx&quot;</span>);<br><span class="hljs-comment">//这里就是模板的sheet索引</span><br><span class="hljs-type">int</span> <span class="hljs-variable">cloneIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">//通过poi创建表对象</span><br><span class="hljs-type">XSSFWorkbook</span> <span class="hljs-variable">workbook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>(inputStream);<br><span class="hljs-comment">//遍历复制sheet</span><br><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Student&gt; entry : sheetMap.entrySet()) &#123;<br>    <span class="hljs-comment">//给复制的sheet命名,这里取的就是map中的key</span><br>workbook.cloneSheet(cloneIndex, entry.getKey());<br>&#125;<br><br><span class="hljs-comment">//移除原始模板sheet</span><br>workbook.removeSheetAt(cloneIndex);<br><span class="hljs-comment">//写到流</span><br>workbook.write(bos);<br></code></pre></td></tr></table></figure><p><strong>3.3 通过EasyExcel导出表格</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//输出文件名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:\out.xlsx&quot;</span>;<br><span class="hljs-comment">//创建模板输入流</span><br><span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br><span class="hljs-comment">//构造表格</span><br><span class="hljs-type">ExcelWriter</span> <span class="hljs-variable">excelWriter</span> <span class="hljs-operator">=</span> EasyExcel.write(filename).withTemplate(is).build();<br><span class="hljs-comment">//填充配置, 这里的意义是给模板中的集合数据添加新行, 保证导出不会错乱</span><br><span class="hljs-type">FillConfig</span> <span class="hljs-variable">fillConfig</span> <span class="hljs-operator">=</span> FillConfig.builder().forceNewRow(Boolean.TRUE).build();<br><br><span class="hljs-comment">//填充汇总数据</span><br><span class="hljs-type">WriteSheet</span> <span class="hljs-variable">writeSheet</span> <span class="hljs-operator">=</span> EasyExcel.writerSheet(<span class="hljs-string">&quot;汇总&quot;</span>).build();<br>excelWriter.fill(list, fillConfig, writeSheet);<br><span class="hljs-comment">//遍历填充详情数据</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Student&gt; entry : sheetMap.entrySet()) &#123;<br><span class="hljs-comment">//获取sheet</span><br>    <span class="hljs-type">WriteSheet</span> <span class="hljs-variable">writeSheet</span> <span class="hljs-operator">=</span> EasyExcel.writerSheet(entry.getKey()).build();<br>    <span class="hljs-comment">//填充对象数据 直接放对象即可</span><br>    excelWriter.fill(entry.getValue(), fillConfig, writeSheet);<br>    <span class="hljs-comment">//填充集合数据 需要放集合</span><br>List&lt;StudentDetail&gt; detailList = entry.getValue().getDetailList();<br>    excelWriter.fill(list, fillConfig, writeSheet);<br>&#125;<br><span class="hljs-comment">//关流</span><br>excelWriter.finish();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>EasyExcel</tag>
      
      <tag>POI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows11安卓子系统添加代理教程</title>
    <link href="/2022/06/win11-aws-proxy.html"/>
    <url>/2022/06/win11-aws-proxy.html</url>
    
    <content type="html"><![CDATA[<h4 id="1-打开WSA，然后打开命令行，用adb连接安卓子系统"><a href="#1-打开WSA，然后打开命令行，用adb连接安卓子系统" class="headerlink" title="1.打开WSA，然后打开命令行，用adb连接安卓子系统"></a>1.打开WSA，然后打开命令行，用adb连接安卓子系统</h4><ul><li>若找不到adb命令，需要把adb配置到环境变量，或者直接在adb.exe所在目录下执行</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">adb connect <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">58526</span><br></code></pre></td></tr></table></figure><h4 id="2-设置全局代理，ip地址为本机内网ip，端口为http代理端口"><a href="#2-设置全局代理，ip地址为本机内网ip，端口为http代理端口" class="headerlink" title="2.设置全局代理，ip地址为本机内网ip，端口为http代理端口"></a>2.设置全局代理，ip地址为本机内网ip，端口为http代理端口</h4><ul><li>ip地址可通过<code>ipconfig</code>获取</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">adb shell settings put global http_proxy ip地址:端口<br></code></pre></td></tr></table></figure><h4 id="3-检验是否代理成功"><a href="#3-检验是否代理成功" class="headerlink" title="3.检验是否代理成功"></a>3.检验是否代理成功</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">adb shell settings get global http_proxy <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Windows11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>WSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker容器迁移教程</title>
    <link href="/2022/06/docker-container-move.html"/>
    <url>/2022/06/docker-container-move.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>被领导要求部署一个和测试环境一样的演示环境，并且数据库也要同步过去，服务器上的各种服务都是docker部署的，由于之前docker玩的比较少，所以还是踩了不少坑的，在此记录一下正确的操作方法。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-容器镜像导出"><a href="#1-容器镜像导出" class="headerlink" title="1.容器镜像导出"></a>1.容器镜像导出</h3><ul><li>我们先通过<code>docker images</code>查看需要导出的镜像</li></ul><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202206171124984.png" alt="镜像列表"></p><ul><li>然后我们使用镜像导出命令</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker save -o <span class="hljs-regexp">/home/</span>备份包名.tar 镜像id或镜像名<br><br>-o(即output) 或 &gt; 表示输出到文件<br>备份镜像可以同时备份多个，空格分隔，这里建议使用镜像名备份，否则还原时会丢失镜像名<br></code></pre></td></tr></table></figure><ul><li>例如我需要备份nginx镜像：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save -o /home/backup/back.tar nginx<br></code></pre></td></tr></table></figure><p><strong>备份完成之后可以在目录下查看到这个备份文件</strong></p><h3 id="2-备份文件迁移"><a href="#2-备份文件迁移" class="headerlink" title="2.备份文件迁移"></a>2.备份文件迁移</h3><ul><li>迁移文件可以使用u盘传输，当然用u盘转移时间显然很慢，我们何不直接在两台服务器之间进行传输？如果再局域网的情况下传输速度会非常快，这里我们使用scp指令去复制备份文件：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">scp <span class="hljs-selector-attr">[参数]</span> <span class="hljs-selector-attr">[原路径]</span> <span class="hljs-selector-attr">[目标路径]</span><br><br>命令参数：<br>-<span class="hljs-selector-tag">p</span> 保留原文件的修改时间，访问时间和访问权限<br>-<span class="hljs-selector-tag">q</span> 不显示传输进度条<br>-r 递归复制整个目录。<br>-v 详细方式显示输出。<br>-<span class="hljs-selector-tag">P</span> port 注意是大写的<span class="hljs-selector-tag">P</span>, port是指定数据传输用到的端口号<br></code></pre></td></tr></table></figure><ul><li>在我们需要迁移的目标机器上执行指令</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#192.168.1.79是我们备份文件所在的服务器，我想把文件移动到本地home下</span><br>scp root@192.168.1.79:/home/back.tar /home/<br></code></pre></td></tr></table></figure><ul><li>回车之后会提示是否输入密码，先yes然后输入密码，输入一下root密码即可，如果你是非root用户，可能要注意下文件权限问题</li></ul><h3 id="3-镜像备份文件读取"><a href="#3-镜像备份文件读取" class="headerlink" title="3.镜像备份文件读取"></a>3.镜像备份文件读取</h3><ul><li>使用docker load载入镜像</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker load -i /home/back.tar<br><span class="hljs-comment">#-i(即input)或&lt;表示从文件输入；</span><br></code></pre></td></tr></table></figure><ul><li>等待读条完毕，使用<code>docker images</code>查看是否导入成功，导入成功即可根据镜像创建容器并运行。</li></ul><h3 id="4-容器挂载目录的转移和配置"><a href="#4-容器挂载目录的转移和配置" class="headerlink" title="4.容器挂载目录的转移和配置"></a>4.容器挂载目录的转移和配置</h3><h4 id="4-1-方案1"><a href="#4-1-方案1" class="headerlink" title="4.1 方案1"></a>4.1 方案1</h4><ul><li>如果在原服务器的容器中配置了挂载目录，可以用第2步的方法，将挂载目录转移至新服务器。</li><li>可以使用以下命令查看挂载目录的映射关系</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker inspect 369a1376f78c | grep Mounts -A 50<br><span class="hljs-comment">#369a1376f78c为容器名称或id 该命令标识获取Mounts关键词后50行</span><br></code></pre></td></tr></table></figure><ul><li>我们查看输出的Mounts数组中的挂载信息，我们可以在此查看挂载的目录和对应容器目录</li></ul><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202206171440713.png" alt="image-20220617144032262"></p><ul><li>在新服务器上启动容器时可以根据挂载信息添加-v参数，</li></ul><h4 id="4-2-方案2（推荐）"><a href="#4-2-方案2（推荐）" class="headerlink" title="4.2 方案2（推荐）"></a>4.2 方案2（推荐）</h4><ul><li><p>如果觉得重新写启动命令很麻烦，可以使用runlike把容器启动命令直接复制过去，方法如下</p><ul><li>安装pip工具包和runlike</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#安装pip3</span><br>yum install python3<br>yum install python3-pip<br><span class="hljs-comment">#安装runlike</span><br>pip3 install runlike<br></code></pre></td></tr></table></figure><ul><li>使用该命令即可查看启动命令，非常方便</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">runlike -p 容器名<br></code></pre></td></tr></table></figure></li></ul><p>参考文章：</p><p><a href="https://blog.csdn.net/qq_37992410/article/details/120286324">docker导入导出镜像、容器，及启动容器失败解决方法</a></p><p><a href="https://www.yuntue.com/post/38484.html">Linux服务器：服务器之间，实现局域网(内网)快速传输文件 - 云服务器网 (yuntue.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/394042562">pip3 install runlike - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows V2rayN直连or代理规则配置教程</title>
    <link href="/2022/06/win-v2ray-direct-proxy-config.html"/>
    <url>/2022/06/win-v2ray-direct-proxy-config.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>V2rayN 在更新以后移除了 PAC 规则模式，很多人被迫要么使用全局代理要么关闭代理，但其实规则模式只是通过另外一种方式呈现在了 V2rayN 里。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="1-打开V2rayN面板，找到设置–路由设置"><a href="#1-打开V2rayN面板，找到设置–路由设置" class="headerlink" title="1.打开V2rayN面板，找到设置–路由设置"></a>1.打开V2rayN面板，找到设置–路由设置</h3><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202206161041896.png"></p><h3 id="2-添加代理-x2F-直连-x2F-组织的域名"><a href="#2-添加代理-x2F-直连-x2F-组织的域名" class="headerlink" title="2.添加代理&#x2F;直连&#x2F;组织的域名"></a>2.添加代理&#x2F;直连&#x2F;组织的域名</h3><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202206161046462.png"></p><h4 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则:"></a>配置规则:</h4><blockquote><p><strong>建议先添加 geoip:cn 和 geosite:cn，然后再以 domain:xxx.com 的形式添加特别网站。</strong><br><strong>(添加完 geoip:cn 和 geosite:cn 以后基本上所有中国大陆的网站都会直连)</strong><br><strong>geosite:category-ads：包含了常见的广告域名。</strong><br><strong>geosite:category-ads-all：包含了常见的广告域名，以及广告提供商的域名。</strong><br><strong>geoip:apple：包含了 Apple 旗下绝大部分域名。</strong><br><strong>geoip:google：包含了 Google 旗下绝大部分域名。</strong><br><strong>geoip:microsoft：包含了 Microsoft 旗下绝大部分域名。</strong><br><strong>geoip:facebook：包含了 Facebook 旗下绝大部分域名。</strong><br><strong>geoip:twitter：包含了 Twitter 旗下绝大部分域名。</strong><br><strong>geoip:telegram：包含了 Telegram 旗下绝大部分域名。</strong></p></blockquote><ul><li>如果你使用的局域网屏蔽了一些你想上的网站，你也可以使用这个功能解除限制，当然需要把想上的网站配置进代理配置中</li></ul><h3 id="3-如果你启用了路由高级功能，想要配置不同模式下的代理规则，也是可以的，如果你不使用高级功能，可以跳过这一步"><a href="#3-如果你启用了路由高级功能，想要配置不同模式下的代理规则，也是可以的，如果你不使用高级功能，可以跳过这一步" class="headerlink" title="3.如果你启用了路由高级功能，想要配置不同模式下的代理规则，也是可以的，如果你不使用高级功能，可以跳过这一步"></a>3.如果你启用了路由高级功能，想要配置不同模式下的代理规则，也是可以的，如果你不使用高级功能，可以跳过这一步</h3><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202206161054968.png"></p><p><strong>每一项代表一个规则集，你可以右击新建规则集去定制化，双击规则集配置规则:</strong></p><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202206161056889.png"></p><p><strong>proxy代表代理，direct代表直连，block代表阻止</strong></p><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202206161057110.png" alt="因为公司内网屏蔽额这些站点（恼），我就让这些站点走了代理"></p><p><strong>配置完只需要一路确定，然后在托盘菜单的路由中选择自己定制化的规则集即可</strong></p><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202206161101779.png"></p><h3 id="4-检查是否生效"><a href="#4-检查是否生效" class="headerlink" title="4.检查是否生效"></a>4.检查是否生效</h3><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/202206161102614.png"></p><p><strong>查看日志，会发现有些域名代理了，有些域名屏蔽了，有些域名直连了，那就是设置成功了。</strong></p><p>参考文章：</p><p><a href="https://hasefukashi.in/v2rayrule/">Windows V2rayN 如何设置 直连or代理 规则？ - Hase測評 (hasefukashi.in)</a></p>]]></content>
    
    
    <categories>
      
      <category>VPN技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>v2rayN</tag>
      
      <tag>v2ray</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker容器时间不同步导致在java应用中获取的时间不正确问题</title>
    <link href="/2022/06/docker-time-java-app.html"/>
    <url>/2022/06/docker-time-java-app.html</url>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>在把Java应用部署到docker容器时，发现应用获取到的时间和现实时间相差了8个小时，会导致一系列不必要的麻烦。</p><h3 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h3><h4 id="1、首选需要确保宿主机的时区和时间的准确"><a href="#1、首选需要确保宿主机的时区和时间的准确" class="headerlink" title="1、首选需要确保宿主机的时区和时间的准确"></a>1、首选需要确保宿主机的时区和时间的准确</h4><p>在宿主机上用 date -R 看一下时区是否为东八区（末尾有+0800）</p><p><img src="https://aunero-blog.oss-cn-hangzhou.aliyuncs.com/img/image-20220610112000077.png"></p><h4 id="2、若宿主机时区或者时间不准确，可以用date-x2F-ntpdate和tzdata同步一下时间以及更改时区"><a href="#2、若宿主机时区或者时间不准确，可以用date-x2F-ntpdate和tzdata同步一下时间以及更改时区" class="headerlink" title="2、若宿主机时区或者时间不准确，可以用date&#x2F;ntpdate和tzdata同步一下时间以及更改时区"></a>2、若宿主机时区或者时间不准确，可以用date&#x2F;ntpdate和tzdata同步一下时间以及更改时区</h4><h5 id="date命令："><a href="#date命令：" class="headerlink" title="date命令："></a>date命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">date                #查看当前时间，结果如下：2017年 01月 06日 星期五 13:02:55 CST<br>date -s 14:03:35#设置当前时间，结果如下：2017年 01月 06日 星期五 14:03:35 CST<br>date -s 2017-01-08    #设置当前日期，结果如下：2017年 01月 08日 星期五 00:00:00  CST<br></code></pre></td></tr></table></figure><h5 id="ntpdate命令："><a href="#ntpdate命令：" class="headerlink" title="ntpdate命令："></a>ntpdate命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ntpdate -u 210.72.145.44   #网络时间同步命令<br></code></pre></td></tr></table></figure><blockquote><p>注意：若不加上-u参数， 会出现以下提示：no server suitable for synchronization found</p><p>-u：从man ntpdate中可以看出-u参数可以越过防火墙与主机同步；</p><p>210.72.145.44：中国国家授时中心的官方服务器。</p></blockquote><h5 id="ntp常用服务器："><a href="#ntp常用服务器：" class="headerlink" title="ntp常用服务器："></a>ntp常用服务器：</h5><p>中国国家授时中心：210.72.145.44</p><p>NTP服务器(上海) ：ntp.api.bz</p><p>经测试中国国家授时中心与NTP上海服务器可以正常同步时间，注意需要加上-u参数！</p><h5 id="时区修改："><a href="#时区修改：" class="headerlink" title="时区修改："></a>时区修改：</h5><p>使用tzselect， 选择到China&#x2F;Shanghai即可</p><p>若显示未安装tzselect，可以安装一下tzdata</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install tzdata #centos<br>apt-get install tzdata #ubuntu<br></code></pre></td></tr></table></figure><h4 id="3、复制宿主机上的zoneinfo文件夹到容器下的-x2F-usr-x2F-share-x2F-目录下。"><a href="#3、复制宿主机上的zoneinfo文件夹到容器下的-x2F-usr-x2F-share-x2F-目录下。" class="headerlink" title="3、复制宿主机上的zoneinfo文件夹到容器下的&#x2F;usr&#x2F;share&#x2F;目录下。"></a>3、复制宿主机上的zoneinfo文件夹到容器下的&#x2F;usr&#x2F;share&#x2F;目录下。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp /usr/share/zoneinfo 容器名称:/usr/share/<br></code></pre></td></tr></table></figure><h4 id="2、进入到容器中"><a href="#2、进入到容器中" class="headerlink" title="2、进入到容器中"></a>2、进入到容器中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it --user=root 容器名称 /bin/bash<br></code></pre></td></tr></table></figure><h4 id="3、创建软连接，修改时区。"><a href="#3、创建软连接，修改时区。" class="headerlink" title="3、创建软连接，修改时区。"></a>3、创建软连接，修改时区。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone<br></code></pre></td></tr></table></figure><h4 id="4、查看时间，进行测试。"><a href="#4、查看时间，进行测试。" class="headerlink" title="4、查看时间，进行测试。"></a>4、查看时间，进行测试。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">date -R<br></code></pre></td></tr></table></figure><ul><li>若容器中有服务，需要重启容器，服务获取的时间才会正确。</li></ul><p>参考文章:</p><p><a href="https://www.linuxprobe.com/linux-time.html">如何调整Linux系统为正确时区 | 《Linux就该这么学》 (linuxprobe.com)</a></p><p><a href="https://www.csdn.net/tags/MtzaIgwsOTY2ODQtYmxvZwO0O0OO0O0O.html">linux中同步时间的命令是什么 - CSDN</a></p><p><a href="https://blog.csdn.net/tiny_du/article/details/124024562">修改docker的时间_在路上的阿帅的博客-CSDN博客_docker 修改时间</a></p>]]></content>
    
    
    <categories>
      
      <category>Java开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Java</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sspanel+XrayR后端+tls+nginx反代(含一键脚本) 对接教程</title>
    <link href="/2022/05/sspanel-xrayr-tls-nginx-proxy.html"/>
    <url>/2022/05/sspanel-xrayr-tls-nginx-proxy.html</url>
    
    <content type="html"><![CDATA[<h2 id="后端信息">后端信息</h2><p>XrayR后端说明：<a href="https://crackair.gitbook.io/xrayr-project/">https://crackair.gitbook.io/xrayr-project/</a></p><p>XrayR原作者已经删库了, 这是后续开发的脚本</p><p><a href="https://github.com/XrayR-project/XrayR">https://github.com/XrayR-project/XrayR</a></p><h2 id="前端配置">前端配置</h2><p>节点地址：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">IP;监听端口;alterId;(tcp或ws);(tls或不填);path=/xxx|<span class="hljs-type">host</span>=xxxx.com|<span class="hljs-type">server</span>=xxx.com|<span class="hljs-type">outside_port</span>=xxx<br></code></pre></td></tr></table></figure><p>类型：V2Ray</p><h2 id="后端配置">后端配置</h2><ul><li>安装后端脚本：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -N https://raw.githubusercontent.com/XrayR-project/XrayR-release/master/install.sh &amp;&amp; bash install.sh<br></code></pre></td></tr></table></figure><ul><li>时间同步 (VMess协议对时间同步有要求, 如果用VLESS可以跳过)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y ntp<br>systemctl enable ntpd<br>ntpdate -q 0.rhel.pool.ntp.org<br>systemctl restart ntpd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改时区:</span><br>tzselect<br>TZ=&#x27;Asia/Shanghai&#x27;;export TZ<br></code></pre></td></tr></table></figure><ul><li>配置文件 /etc/XrayR/config.yml, 以下为部分修改项</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Nodes:</span><br>  <span class="hljs-bullet">-</span><br>    <span class="hljs-attr">PanelType:</span> <span class="hljs-string">&quot;SSpanel&quot;</span> <span class="hljs-comment"># 面板类型: SSpanel, V2board, PMpanel, Proxypanel</span><br>    <span class="hljs-attr">ApiConfig:</span><br>      <span class="hljs-attr">ApiHost:</span> <span class="hljs-string">&quot;https://xxx.com&quot;</span>  <span class="hljs-comment">#api地址 机场地址</span><br>      <span class="hljs-attr">ApiKey:</span> <span class="hljs-string">&quot;123123&quot;</span><span class="hljs-comment">#apikey 在你网站的config里配置过的</span><br>      <span class="hljs-attr">NodeID:</span> <span class="hljs-number">15</span><span class="hljs-comment">#节点id</span><br>      <span class="hljs-attr">EnableVless:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Enable Vless for V2ray Type vless协议比较快</span><br>    <span class="hljs-attr">ControllerConfig:</span><br>      <span class="hljs-attr">ListenIP:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># IP address you want to listen 监听ip, 反代需要填</span><br>      <span class="hljs-attr">CertConfig:</span><br>        <span class="hljs-attr">CertMode:</span> <span class="hljs-string">none</span> <span class="hljs-comment">#反代直接关闭 交给后面的脚本申请证书</span><br></code></pre></td></tr></table></figure><h3 id="后续">后续</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输出当前配置文件内容</span><br>xrayr config<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动xrayr</span><br>xrayr start<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">指令向导</span><br>xrayr<br></code></pre></td></tr></table></figure><h2 id="BBR加速">BBR加速</h2><p>centos bbr</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">功能比较强大</span><br>bash &lt;(curl -Lso- https://git.io/kernel.sh)<br></code></pre></td></tr></table></figure><h2 id="配置反代">配置反代</h2><p>使用前先将域名解析到后端节点ip地址</p><p>一键脚本，按照提示操作即可，脚本跑完会给出前端节点配置信息，需要去节点配置改一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash &lt;(curl -sL https://raw.githubusercontent.com/Aunero/XrayR-nginx-proxypass/master/install.sh)<br></code></pre></td></tr></table></figure><p>部署完成之后记得也要开放一下防火墙你设置的监听端口，或者直接关闭防火墙，否则节点可能会连不上，可以参考这篇文章：<a href="https://aunero.top/2022/08/Linux-firewall-cmd.html">Linux防火墙常用命令 - Aunero’s Blog</a></p>]]></content>
    
    
    <categories>
      
      <category>VPN技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>v2ray</tag>
      
      <tag>sspanel</tag>
      
      <tag>XrayR</tag>
      
      <tag>nginx</tag>
      
      <tag>反向代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux自动重启配置教程</title>
    <link href="/2022/05/linux-auto-reboot.html"/>
    <url>/2022/05/linux-auto-reboot.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将时区改成中国</span><br><br>crontab -e <br><br>30 4 * * * /sbin/reboot          <br><span class="hljs-meta prompt_"># </span><span class="language-bash">( 0 1 * * *表示每天凌晨4.30重启.)</span><br><br>0 1 * * 1 /sbin/reboot          <br><span class="hljs-meta prompt_"> # </span><span class="language-bash">(0 1 * * 1表示每周一凌晨一点重启</span><br><br>30 2 * * * /home/bin/oraclebackup.sh   <br><span class="hljs-meta prompt_">#</span><span class="language-bash">（备份数据库和站点目录）</span><br><br>30 3 * * * /home/bin/cmsbackup.sh     <br><span class="hljs-meta prompt_">#</span><span class="language-bash">（备份数据库和站点目录）</span><br><br>crontab -l <br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看目前已有的定时任务</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">重启cron生效</span><br>service crond restart <br><br>/etc/init.d/crond start #启动<br>/etc/init.d/crond stop #关闭<br>/etc/init.d/crond restart #重启<br><span class="hljs-meta prompt_"># </span><span class="language-bash">有的系统可能init.d目录下没有crond，只有cron，其实也一样，只不过把crond换为cron：</span><br>/etc/init.d/cron start  #启动<br>/etc/init.d/cron stop #关闭<br>/etc/init.d/cron restart #重启<br><br>who -b #查看最后一次系统启动的时间。<br><br>who -r #查看当前系统运行时间<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>cron表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
